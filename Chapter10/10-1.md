### 广度优先搜索

话不多说，直接上题（青少年 CTF 练习平台）

![](https://pic1.imgdb.cn/item/687857b258cb8da5c8bc0c56.png)

python 的 exe 3.11 解包反编译发现往下走才会给出完整地图 还有出口 直接手动走一下得到

```python
################################   
#Y#                   #       X#   
# # ############# ### # ### ## #   
# #   #         # #   #   #   ##   
# ##### ####### ### # ### ### ##   
#   #   #     # #   #   # #   ##   
### # ### ##### # ####### # ####   
# #   # #     # #     #   #   ##   
# ##### # ### # # ### # ##### ##   
#         #   # #   #       # ##   
# ######### # # ############# ##   
#   # #     # #   #           ##   
### # # ######### # ######### ##   
# # # #           # #       # ##   
# # # ############# # ##### # ##   
#   #       #       # #   #   ##   
#X ## ### ### # ##### # ########   
#   #   #     #   # # #   #   ##   
### ### ######### # # # # # # ##   
# # #   #   #   # # # # # # # ##   
# # ### # # # # # # # ### # # ##   
# #   # # #   #   #   #   # # ##   
# ### ### ########### # # # # ##   
#   #   #           # # # # # ##   
# ##### # ######### # # ### # ##   
#   #   #   #       # # #   # ##   
### # ####### ####### # # ### ##   
#   #   #   # #     # #   #   ##   
# ##### # # # # ##### ##### # ##   
#         #   #             #   #   
#X ############ X ########### X#   
################################
```

搓个 BFS 跑一下最短路径

```python
from collections import deque   

def parse_map(map_str):   
    map_data = map_str.strip().split('\n')   
    rows = len(map_data)   
    cols = len(map_data[0]) if rows > 0 else 0   
    start = None   
    exits = []   
    for y in range(rows):   
        for x in range(cols):   
            if map_data[y][x] == 'Y':   
                start = (y, x)   
            elif map_data[y][x] == 'X':   
                exits.append((y, x))   
    return map_data, start, exits   


def bfs(start, targets, map_data):   
    rows = len(map_data)   
    cols = len(map_data[0])   
    visited = {}   
    queue = deque([(start[0], start[1])])   
    visited[(start[0], start[1])] = (None, None, 0)   
    directions = [(-1, 0, 'w'), (1, 0, 's'), (0, -1, 'a'), (0, 1, 'd')]   
    found_targets = []   

    while queue:   
        y, x = queue.popleft()   
        current_dist = visited[(y, x)][2]   

        if (y, x) in targets:   
            found_targets.append((y, x, current_dist))   

        for dy, dx, move in directions:   
            ny, nx = y + dy, x + dx   
            if 0 <= ny < rows and 0 <= nx < cols:   
                if map_data[ny][nx] != '#' and (ny, nx) not in visited:   
                    visited[(ny, nx)] = (y, x, current_dist + 1)   
                    queue.append((ny, nx))   

    if not found_targets:   
        return None, None   
    target = min(found_targets, key=lambda x: x[2])   
    path = []   
    current = (target[0], target[1])   
    while True:   
        prev_info = visited.get(current)   
        if prev_info is None or prev_info[0] is None:   
            break   
        py, px = prev_info[0], prev_info[1]   
        dy = current[0] - py   
        dx = current[1] - px   
        if dy == 1:   
            move = 's'   
        elif dy == -1:   
            move = 'w'   
        elif dx == 1:   
            move = 'd'   
        else:   
            move = 'a'   
        path.append(move)   
        current = (py, px)   
    path.reverse()   
    return ''.join(path), (target[0], target[1])   


def find_shortest_path(map_str):   
    map_data, start, exits = parse_map(map_str)   
    current_pos = start   
    remaining_exits = set(exits)   
    total_path = []   
    path_details = []   # 存储每个阶段的路径详情   

    while remaining_exits:   
        path, exit_pos = bfs(current_pos, remaining_exits, map_data)   
        if not path:   
            break   
        total_path.append(path)   

        path_details.append({   
            'from': current_pos,   
            'to': exit_pos,   
            'path': path,   
            'length': len(path)   
        })        current_pos = exit_pos   
        remaining_exits.remove(exit_pos)   

    # 打印每个阶段的路径   
    for i, segment in enumerate(path_details):   
        print(f"阶段 {i + 1}: 从 {segment['from']} 到 {segment['to']}")   
        print(f"路径: {segment['path']}")   
        print(f"长度: {segment['length']}\n")   

    full_path = ''.join(total_path)   
    return full_path   


map_str = """   
################################   
#Y#                   #       X#   
# # ############# ### # ### ## #   
# #   #         # #   #   #   ##   
# ##### ####### ### # ### ### ##   
#   #   #     # #   #   # #   ##   
### # ### ##### # ####### # ####   
# #   # #     # #     #   #   ##   
# ##### # ### # # ### # ##### ##   
#         #   # #   #       # ##   
# ######### # # ############# ##   
#   # #     # #   #           ##   
### # # ######### # ######### ##   
# # # #           # #       # ##   
# # # ############# # ##### # ##   
#   #       #       # #   #   ##   
#X ## ### ### # ##### # ########   
#   #   #     #   # # #   #   ##   
### ### ######### # # # # # # ##   
# # #   #   #   # # # # # # # ##   
# # ### # # # # # # # ### # # ##   
# #   # # #   #   #   #   # # ##   
# ### ### ########### # # # # ##   
#   #   #           # # # # # ##   
# ##### # ######### # # ### # ##   
#   #   #   #       # # #   # ##   
### # ####### ####### # # ### ##   
#   #   #   # #     # #   #   ##   
# ##### # # # # ##### ##### # ##   
#         #   #             #   #   
#X ############ X ########### X#   
################################   
"""   

path = find_shortest_path(map_str)   
print(f"完整路径: {path}")   
print(f"总长度: {len(path)}")   
print(f"最后四步: {path[-4:] if len(path) >= 4 else path}")
```

跑出来不对，猜测有多解 经过手扣发现有的地方路径不唯一 具体如下

```python
ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssa(as,sa)(sd,ds)dssssddssddssaassddssaaaaa(as,sa)(wd,dw)dddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaa(as,sa)(wd,dw)ddddddddddwwddss(ds,sd)
```

直接写脚本算一下符合条件的每一个的 md5 提交即可（从后往前第一个就是）

```python
import re   
import hashlib   
from itertools import product   

path_str = (   
"ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssa(as,sa)(sd,ds)dssssddssddssaassddssaaaaa(as,sa)(wd,dw)dddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaa(as,sa)(wd,dw)ddddddddddwwddss(ds,sd)"   
)   

pattern = re.compile(r'\(([^()]+)\)')   
segments = []   
last_index = 0   

for match in pattern.finditer(path_str):   
    segments.append([path_str[last_index:match.start()]])   
    options = match.group(1).split(',')   
    segments.append(options)   
    last_index = match.end()   

segments.append([path_str[last_index:]])   

combinations = [''.join(p) for p in product(*segments)]   

result = []   
for path in combinations:   
    if path.endswith('ssds'):   
        md5_hash = hashlib.md5(path.encode()).hexdigest()   
        result.append((path, f'palu{{{md5_hash}}}'))   

for path, md5 in result:   
    print(f"{md5}:\n{path}\n")   

print(f"共匹配路径数量: {len(result)}")
```

路径为

```python
ssssddssddwwddwwddddddddssssssssddssaaaaaaaaaawwddddwwddwwaaaassaaaaaaaassddssssasadsdssssddssddssaassddssaaaaasadwdddddddwwddssddwwwwddddddwwaaaaaaaaaawwwwddssddwwddssddwwwwaawwddddwwwwddddddddddwwwwaawwddwwaawwdddaaassddssaassddssssssssaawwaaaaaassssssssssssssssaaaasadwddddddddddwwddssds
```

flag：`palu{990fd7773f450f1f13bf08a367fe95ea}`