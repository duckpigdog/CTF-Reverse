### 魔改 RC4 加密破解

话不多说，直接上题（青少年 CTF 练习平台）

![](https://pic1.imgdb.cn/item/68786e8c58cb8da5c8bcaedd.png)

IDA 反编译，有花指令，NOP 掉

![](https://pic1.imgdb.cn/item/68786ecf58cb8da5c8bcb572.png)

进入 main 函数 有个 hook 函数 跟进

密文密钥如下

![](https://pic1.imgdb.cn/item/687872d058cb8da5c8bcdefa.png)

跟进下面的函数发现是个魔改的 RC4

![](https://pic1.imgdb.cn/item/687872f558cb8da5c8bce007.png)

| 标准 RC4 特征                          | 此代码特征                                          |
| -------------------------------------- | --------------------------------------------------- |
| `j = (j + S[i] + K[i % keylen]) % 256` | `v5 = (v9[k] + v5 + *(k + a1)) % 233`               |
| 交换 S[i] 与 S[j]                      | 同样交换 `(k + a1)` 与 `(v5 + a1)`                  |
| 模数 256                               | 魔改成了 **233**                                    |
| 单次循环 256 次                        | 这里居然 **重复 3 次**（`for (j = 0; j < 3; ++j)`） |

写脚本解密即可

```python
def KSA(key):   
    S = list(range(256))   
    v5 = 0
    for _ in range(3):    
for k in range(256):   
            v5 = (key[k % len(key)] + v5 + S[k]) % 233
            S[k], S[v5] = S[v5], S[k]   
    return S   

def PRGA(S):
    i, j = 0, 0
    whileTrue:   
        i = (i + 1) % 256
        j = (j + S[i]) % 256
        S[i], S[j] = S[j], S[i]   
        K = S[(S[i] + S[j]) % 256]   
        yield K   

def RC4(key, ciphertext):
    cipher_bytes = bytes(ciphertext)   
    S = KSA(key)   
    keystream = PRGA(S)   
    return bytes([c ^ next(keystream) for c in cipher_bytes])   

key = b'forpalu'
enc = [13, 176, 191, 10, 141, 47, 2, 56, 111, 25, 174, 153, 25, 199,   
            110, 247, 79, 203, 144, 78, 85, 142, 209, 16, 192]   

flag = RC4(key, enc)   
print(flag.decode())
#palu{G00d_P1au_Kn0w_H00K}
```

