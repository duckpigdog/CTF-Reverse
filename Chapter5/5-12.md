### RC4 加密破解

话不多说，直接上题（青少年 CTF 练习平台）

![](https://pic1.imgdb.cn/item/6866972c58cb8da5c88dd132.png)

加密过程在这个函数中

![](https://pic1.imgdb.cn/item/686697e558cb8da5c88dd487.png)

首先第一个是密钥的生成

![](https://pic1.imgdb.cn/item/6866984058cb8da5c88dd65a.png)

**KSA详细步骤：**

1. 初始化 S 盒：创建 256 字节数组，初始化为 0-255
   - S[0] = 0, S[1] = 1, ..., S[255] = 255
2. 密钥扰乱：
   - 初始化计数器 j=0
   - 对每个 i 从 0 到 255：
     - j = (j + S[i] + key[i % key_length]) % 256
     - 交换 S[i] 和 S[j]

```c
__int64 __fastcall sub_40067A(const char *a1, __int64 a2)
{
  // a1: 指向密钥字符串的指针（即前面的 "Nu1Lctf233"）
  // a2: 指向一个 256 字节数组的指针（用于初始化 S 盒）
  int v3; // [rsp+10h] [rbp-10h]	// 临时变量，用于交换索引
  int i; // [rsp+14h] [rbp-Ch]	    // 循环计数器
  int j; // [rsp+18h] [rbp-8h]		// 循环计数器
  int v6; // [rsp+1Ch] [rbp-4h]		// 存储密钥长度

  v6 = strlen(a1);		// 获取密钥长度(10)
  v3 = 0;
   
  // 初始化 S 盒：0,1,2,...,255
  for ( i = 0; i <= 255; ++i )
    *(i + a2) = i;
  
  // j % v6：循环使用密钥的每个字节（因为密钥通常比S盒短）
  for ( j = 0; j <= 255; ++j )
  {
    v3 = (*(j + a2) + v3 + a1[j % v6]) % 256;		// v3 计算
    sub_400646(j + a2, a2 + v3);	// 交换函数
  }
  return 0LL;
}
```

**PRGA详细步骤：**

1. 初始化 i=0, j=0
2. 对于每个输入字节：
   - i = (i + 1) % 256
   - j = (j + S[i]) % 256
   - 交换 S[i] 和 S[j]
   - t = (S[i] + S[j]) % 256
   - 密钥流字节 k = S[t]
   - 输出字节 = 输入字节 ^ k

```c
__int64 __fastcall sub_400753(__int64 a1, const char *a2, __int64 a3)
{
  // a1: 指向初始化后的 S 盒（由 KSA 生成）
  // a2: 指向要加密/解密的输入数据（明文或密文）
  // a3: 指向输出缓冲区（将存储加密/解密结果）
  int v5; // [rsp+24h] [rbp-1Ch]
  int v6; // [rsp+28h] [rbp-18h]
  size_t v7; // [rsp+30h] [rbp-10h]
  size_t v8; // [rsp+38h] [rbp-8h]

  v5 = 0;		// 对应 RC4 中的 i
  v6 = 0;		// 对应 RC4 中的 j
  v7 = 0LL;		// 循环计数器，跟踪处理了多少字节
  v8 = strlen(a2);		// 输入数据的长度
  while ( v7 < v8 )
  {
    v5 = (v5 + 1) % 256;	// 更新 i
    v6 = (v6 + *(v5 + a1)) % 256;	// 更新 j
    sub_400646(v5 + a1, a1 + v6);	// 交换 S[i] 和 S[j]
    *(a3 + v7) = a2[v7] ^ *((*(v5 + a1) + *(v6 + a1)) + a1);	// 生成密钥流字节并异或
    ++v7;
  }
  return 0LL;
}
```

```
graph TD
    A[开始] --> B[输入密钥和明文]
    B --> C[KSA密钥调度]
    C --> D[PRGA生成密钥流]
    D --> E[明文与密钥流异或]
    E --> F[输出密文]
```

可知本题的密钥是`Nu1Lctf233`

![](https://pic1.imgdb.cn/item/6868a3f8f8595c5440cf4353.png)

加密后的密文是

```
[0xc6,0x21,0xca,0xbf,0x51,0x43,0x37,0x31,0x75,0xe4,0x8e,0xc0,0x54,0x6f,0x8f,0xee,0xf8,0x5a,0xa2,0xc1,0xeb,0xa5,0x34,0x6d,0x71,0x55,0x8,0x7,0xb2,0xa8,0x2f,0xf4,0x51,0x8e,0xc,0xcc,0x33,0x53,0x31,0x0,0x40,0xd6,0xca,0xec,0xd4]
```

转换一下

```python
import base64

a = [0xc6, 0x21, 0xca, 0xbf, 0x51, 0x43, 0x37, 0x31, 0x75, 0xe4, 0x8e, 0xc0, 0x54, 0x6f, 0x8f, 0xee, 0xf8, 0x5a, 0xa2,
     0xc1, 0xeb, 0xa5, 0x34, 0x6d, 0x71, 0x55, 0x8, 0x7, 0xb2, 0xa8, 0x2f, 0xf4, 0x51, 0x8e, 0xc, 0xcc, 0x33, 0x53,
     0x31, 0x0, 0x40, 0xd6, 0xca, 0xec, 0xd4]
s = ""
for i in a:
    s += chr(i)

print(str(base64.b64encode(s.encode('utf-8')), 'utf-8'))
```

**解密过程：**

1. 准备数据

```python
a = [0xc6,0x21,...]  # 加密后的字节数组
s = ""
for i in a:
    s += chr(i)  # 将字节值转换为字符
```

2. Base64 编码

```python
s = str(base64.b64encode(s.encode('utf-8')), 'utf-8')
```

3. RC4 KSA 初始化

```python
def rc4_init_sbox(key):
    s_box = list(range(256))  # [0,1,2,...,255]
    j = 0
    for i in range(256):
        j = (j + s_box[i] + ord(key[i % len(key)])) % 256
        s_box[i], s_box[j] = s_box[j], s_box[i]  # 交换
    return s_box
```

4. RC4 解密

```python
def rc4_excrypt(plain, box):
    plain = base64.b64decode(plain.encode('utf-8'))  # Base64 解码
    plain = bytes.decode(plain)  # 字节转字符串
    res = []
    i = j = 0
    for s in plain:  # 遍历字符串的每个字符
        i = (i + 1) % 256
        j = (j + box[i]) % 256
        box[i], box[j] = box[j], box[i]
        t = (box[i] + box[j]) % 256
        k = box[t]
        res.append(chr(ord(s) ^ k))  # 字符转 ASCII 值，异或，再转回字符
    cipher = "".join(res)
    return cipher
```

完整代码如下：

```python
def rc4_decrypt(key, ciphertext):
    # KSA: 密钥调度算法
    s_box = list(range(256))
    j = 0
    key_bytes = key.encode('latin1')  # 保持字节不变
    
    for i in range(256):
        j = (j + s_box[i] + key_bytes[i % len(key_bytes)]) % 256
        s_box[i], s_box[j] = s_box[j], s_box[i]
    
    # PRGA: 伪随机生成算法
    i = j = 0
    plaintext = bytearray()
    
    for byte in ciphertext:
        i = (i + 1) % 256
        j = (j + s_box[i]) % 256
        s_box[i], s_box[j] = s_box[j], s_box[i]
        t = (s_box[i] + s_box[j]) % 256
        k = s_box[t]
        plaintext.append(byte ^ k)  # 直接字节级异或
    
    return bytes(plaintext)

# 原始加密数据（45字节）
ciphertext = bytes([
    0xC6, 0x21, 0xCA, 0xBF, 0x51, 0x43, 0x37, 0x31, 
    0x75, 0xE4, 0x8E, 0xC0, 0x54, 0x6F, 0x8F, 0xEE,
    0xF8, 0x5A, 0xA2, 0xC1, 0xEB, 0xA5, 0x34, 0x6D, 
    0x71, 0x55, 0x08, 0x07, 0xB2, 0xA8, 0x2F, 0xF4,
    0x51, 0x8E, 0x0C, 0xCC, 0x33, 0x53, 0x31, 0x00,
    0x40, 0xD6, 0xCA, 0xEC, 0xD4
])

key = "Nu1Lctf233"
plaintext = rc4_decrypt(key, ciphertext)

print("Decrypted:", plaintext)
print("As string:", plaintext.decode('utf-8', errors='replace'))
```

