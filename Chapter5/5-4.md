### 字符串爆破

话不多说，直接上题（BUUCTF）

![](https://pic1.imgdb.cn/item/67a5de27d0e0a243d4fc9292.jpg)

扔到 IDA64 反编译，看到先调用了 Decry 加密函数

![](https://pic1.imgdb.cn/item/67a5de84d0e0a243d4fc92b9.jpg)

倒着看是比较 text 与 str2 的值

![](https://pic1.imgdb.cn/item/67a5df9dd0e0a243d4fc92db.jpg)

往上看找到关于 str2 算法，v2 初始值是 0，这里应该是遍历 str2 的每个字符，v1 又是读取输入的字符串，暂时不管

v3 初始值为 0，v5 是 key 的长度，现在未知的是 key，去找 key

![](https://pic1.imgdb.cn/item/67a5e022d0e0a243d4fc92e6.jpg)

strcpy() 将 key1 复制给 key，strcat() 将 src 拼在 key 后面

![](https://pic1.imgdb.cn/item/67a5e0dad0e0a243d4fc92fe.jpg)

双击 key1 拿到字符串

![](https://pic1.imgdb.cn/item/67a5e177d0e0a243d4fc932e.jpg)

src 的值是以十六进制的形式给出

![](https://pic1.imgdb.cn/item/67a5e34ad0e0a243d4fc938c.jpg)

在线网站转 ASCII 码，注意要颠倒顺序

数据在内存中是小端顺序，高位在高地址处，低位在低地址处

故实际的字符顺序应为 "NDCLS

![](https://pic1.imgdb.cn/item/67a5e373d0e0a243d4fc9395.jpg)

还有一处关于 key 的算法，遍历 key 中的字符，因为 v3 = 0，v5 = 10，所以 if 条件成立

看到 + 32 推测是大写转小写，具体可以参考 ASCII 表，A = 65， a = 97，所以最后 key = "adsfkndcls"

![](https://pic1.imgdb.cn/item/67a5e3a7d0e0a243d4fc939e.jpg)

现在来看 text，join() 与 strcat() 同理

![](https://pic1.imgdb.cn/item/67a5e3cdd0e0a243d4fc93a3.jpg)

同理解出 v9 = "hadow"

![](https://pic1.imgdb.cn/item/67a5e3eed0e0a243d4fc93a6.jpg)

拿到 key3 = "kills"，所以 text = "killshadow"

![](https://pic1.imgdb.cn/item/67a5e595d0e0a243d4fc9404.jpg)

因为 str2 还有个 v1 参数是未确定的，所以遍历爆破 str2 与 text 比较，成功拿到 flag

```python
text = 'killshadow'
key = 'adsfkdcls'

v3 = 0
v5 = len(key)
dict1 = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'
flag = ''

for i in range(0, 10):
	for char in dict1:
		x = (ord(char) - 39 - ord(key[v3 % v5] + 97) % 26 + 97
		if chr(x) == text[i]:
			flag += char
			
		v3 += 1
		
print(flag)
```