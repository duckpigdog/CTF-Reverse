### GDB 断点读取寄存器

话不多说，直接上题（攻防世界）

![](https://pic1.imgdb.cn/item/6808d09158cb8da5c8c68eb3.png)

IDA32 反编译

![](https://pic1.imgdb.cn/item/6808d0e258cb8da5c8c6904b.png)

核心函数是最后一个

![](https://pic1.imgdb.cn/item/6808d14658cb8da5c8c69225.png)

通过第 10~13 行代码，我们可以知道 `s2` 就是我们需要 flag（ws 为输入值）

相同则打印 `success!`

![](https://pic1.imgdb.cn/item/6808d21b58cb8da5c8c6963f.png)

鼠标放到 `s2 = decrypt(&s, &dword_8048A90);` 这一段然后按 TAB 反编译即可自动定位到汇编代码部分

通过图中红框我们可以知道 `eax` 储存着 `decryp()` 函数返回的 flag 值，再保存到 `s2`

![](https://pic1.imgdb.cn/item/6808d54f58cb8da5c8c6a13c.png)

简单看看 `decryp()` 函数

![](https://pic1.imgdb.cn/item/6808d5aa58cb8da5c8c6a151.png)

综上所述，我们需要的 flag 保存在 `eax` 中

因此我们可以将断点设置在 `decrypt()` 函数处，单步执行后，`eax` 保存着我们需要的值，再读取 `eax` 值即可

先下好断点

```shell
pwndbg> b decrypt
```

![](https://pic1.imgdb.cn/item/6808d6b558cb8da5c8c6a198.png)

按 `r` 执行到断点

![](https://pic1.imgdb.cn/item/6808d6ed58cb8da5c8c6a1b7.png)

再按 `n` 不跟进函数

然后查看 `eax` 寄存器拿到 flag

![](https://pic1.imgdb.cn/item/6808da2358cb8da5c8c6a2a2.png)